<?php
  // $Id: ed_classified.module,v 1.1.4.17 2007/02/25 23:05:04 inactivist Exp $

  /**
   * Simple text-based classified ads module.
   * Michael Curry, Exodus Development, Inc.
   * exodusdev@gmail.com
   * for more information, please visit http://exodusdev.com/drupal/modules/classified.module
   * Copyright (c) 2006, 2007 Exodus Development, Inc.  All Rights Reserved. 
   * Licensed under the terms of the GNU Public License (GPL) version 2.  Please see LICENSE.txt for
   * license terms.  Posession and use of this code signifies acceptance of license
   * terms.
   */
  
  /** 
   * If you want to remove taxonomy links from the node, and you are using the phptemplate theme engine,
   * Simply create a node-ed_classified.tpl.php and remove (or modify) the contents of the $terms 
   * theme variable.  $taxonomy array is also available.
   * See: http://drupal.org/node/46012
   */

define('EDI_CLASSIFIED_MODULE_NAME', 'ed_classified');
define('EDI_CLASSIFIED_MODULE_VERSION', '$Id: ed_classified.module,v 1.1.4.17 2007/02/25 23:05:04 inactivist Exp $');

define('EDI_CLASSIFIED_VAR_DEF_BODYLEN_LIMIT', 500);
define('EDI_CLASSIFIED_VAR_DEF_EXPIRATION_DAYS', 30);
define('EDI_CLASSIFIED_VAR_DEF_PURGE_AGE', 15);               // how many days after expiration to purge ads?
define('EDI_CLASSIFIED_VAR_DEF_SHOW_CONTACT_LINK_ON_POSTS', TRUE);
define('EDI_CLASSIFIED_VAR_DEF_SEND_EMAIL_REMINDERS', FALSE);
define('EDI_CLASSIFIED_VAR_DEF_ALTER_ATTACHMENT_TEXT', TRUE); // If upload_image module is present, offer enhanced functionality
define('EDI_CLASSIFIED_VAR_DEF_ALTER_ATTACHMENT_TEXT_DESCRIPTION', 'Add any photos or other images to your ad here.  Please be sure to check the \'list\' checkbox in order to ensure that the photo is visible in your ad.  Note that changes made to the attachments are not permanent until you save this classified ad by clicking the [Submit] button.');


/** 
 * Define user notification types (for future use.)
 */

define('EDI_CLASSIFIED_NOTIFICATION_AD_PERIODIC',         0); /// Periodic user notifications 
define('EDI_CLASSIFIED_NOTIFICATION_AD_EXPIRED',          1); /// Notification on ad expired
define('EDI_CLASSIFIED_NOTIFICATION_AD_EXPIRING_SOON',    2); /// An ad is expiring soon

define('EDI_CLASSIFIED_SECS_IN_DAY', 86400);                  // # secs in a day


/** UNUSED AT PRESENT 
 define('EDI_CLASSIFIED_STATE_ACTIVE', 0);
 define('EDI_CLASSIFIED_STATE_EXPIRED', 1);
**/


/**
 * config variable helpers
 */

function _ed_classified_cfg_varname($name)
{
  // ensure unique varnames for this module
  return  EDI_CLASSIFIED_MODULE_NAME .'_'. $name;
}

function _ed_classified_variable_get($name, $defval, $log=FALSE) {
  $val = variable_get(_ed_classified_cfg_varname($name),$defval);
  if ($log) {
    _edi_wd(sprintf('variable_get \'%s\'= \'%s\'',
                    _ed_classified_cfg_varname($name),
                    $val));
  }
  return $val;
}

function _ed_classified_variable_set($name, $newval, $log=FALSE) {
  if ($log) {
    _edi_wd(sprintf('variable_set \'%s\' changed from \'%s\' to \'%s\'',
                    _ed_classified_cfg_varname($name),
                    _ed_classified_variable_get($name, ''),
                    $newval));
  }
  variable_set(_ed_classified_cfg_varname($name),$newval);
}

/**
 * Implementation of hook_block().
 * 
 */
function ed_classified_block($op = 'list', $delta = 0, $edit = array()) {
  $parms = _ed_classified_displayname_parms();
  if ($op == 'list') {
    $blocks[0]['info'] = t('@name - Popular (requires access log enabled)', $parms);
    $blocks[1]['info'] = t('@name - Latest', $parms); 
    $blocks[2]['info'] = t('@name - Stats', $parms);
    return $blocks;
  }
  else if ($op == 'configure') {
    // OPTIONAL: Enter form elements to add to block configuration screen, if required.    
  }
  else if ($op == 'save') {
    // OPTIONAL: Add code to trigger when block configuration is saved, if required.
  }
  else if ($op == 'view') {
    if (user_access('access content')) {
      switch ($delta) {
      case 0:
        $block['subject'] = t('Popular @name', $parms);
        $block['content'] = ed_classified_get_popular_ads_list();
        break;
      case 1:
        $block['subject'] = t('Latest @name', $parms);
        $block['content'] = ed_classified_get_latest_ads_list();
        break; 

      case 2:
        $block['subject'] = t('@name Statistics', $parms); 
        $block['content'] = ed_classified_get_ad_stats();
        break;
      }
    }
    return $block;
  }
}

/**
 * Get stats 
 */
function ed_classified_get_ad_stats() {
  return theme('ed_classified_ads_stats');
}

function theme_ed_classified_ads_stats()
{
  $stats =  array('!adcount' => ed_classified_get_adcount(TRUE), '!ads_today'=> ed_classified_get_adcount_for_time_range(time()-EDI_CLASSIFIED_SECS_IN_DAY, time(), TRUE));
  $content = '<div class="classified-ad-block item-list"><ul>';
  $content .= '<li>' .  t('!adcount ads total.', $stats) . '</li>'; // todo: format_plural() http://api.drupal.org/api/HEAD/function/format_plural
  $content .= '<li>' . t('!ads_today ads in last 24 hours.', $stats) . '</li>'; // todo: format_plural()
  $content .= '</ul></div>';
  return $content;
}

function ed_classified_get_adcount($only_published) {
  if ($only_published) $status = 'status=1 AND';
  $qr = db_query("SELECT COUNT(nid) as c FROM node WHERE $status type='ed_classified';");
  $o = db_fetch_object($qr);
  return $o->c;
}
/**
 * Get ad count for time range
 */
function ed_classified_get_adcount_for_time_range($start_time, $end_time, $only_published) {
  if ($only_published) $status = 'status=1 AND';
  $qr = db_query("SELECT COUNT(nid) as c FROM node WHERE $status type='ed_classified' AND  created >= %d AND created <=%d;", $start_time, $end_time);
  $o= db_fetch_object($qr);
  return $o->c;
}

/**
 * Get a list of popular ads for block use 
 */
function ed_classified_get_popular_ads_list() {
  $output = '';
  $have_statistics = _ed_classified_module_exists('statistics');
  if ($have_statistics) {
    $q = db_query("SELECT n.nid, n.title, n.created, n.changed, s.totalcount as counter FROM {node_counter} s INNER JOIN {node} n ON s.nid = n.nid WHERE n.status = 1 AND n.type = '%s' ORDER BY s.totalcount DESC LIMIT %d;", EDI_CLASSIFIED_MODULE_NAME, _ed_classified_variable_get('block_popular_limit', 4));
    $output = theme('ed_classified_ads_block', _ed_classified_query_results_to_array($q), FALSE, TRUE, TRUE);
  }
  return $output;
}


/**
 * Get a list of latest ads for block use
 */
function ed_classified_get_latest_ads_list() {
  $q = db_query('select title, nid, created as timestamp, changed from {node} where type="ed_classified" AND status = 1 ORDER BY created DESC LIMIT %d;', _ed_classified_variable_get('block_latest_limit', 4));
  return theme('ed_classified_ads_block', _ed_classified_query_results_to_array($q), TRUE, FALSE, TRUE );
}

/**
 * Convert db_query results to an array
 */ 
function _ed_classified_query_results_to_array($qr) {
  $arr = array();
  while ($info = db_fetch_object($qr)) {
    $arr[] = $info;
  }
  return $arr;
}

/**
 * Helper function to determine the single ad category name to which this node belongs.
 */
function _ed_classified_get_primary_category($node) {
  // lifted from _nodeapi implementation - crude, need to find out if there's a better way to get the single term for this node.
  $terms = taxonomy_node_get_terms_by_vocabulary($node->nid, _ed_classified_get_vid());
  $term = array_pop($terms);
  if ($term) {
    $vocabulary = taxonomy_get_vocabulary(_ed_classified_get_vid());
    if ($parents = taxonomy_get_parents_all($term->tid)) {
      return $parents[0];
    }
  }
}


/** 
 * Theme an ads block
 * TODO: change this name to theme_classified_ads_block
 */
function theme_ed_classified_ads_block($ads, $display_timestamp=TRUE, $display_counter=FALSE, $display_ad_category=FALSE) {
  //    var_dump($ads); 
  $content = '<div class="classified-ad-block item-list"><ul>';
  foreach($ads as $x) {
    $content .= '<li>'. l($x->title, 'node/'.$x->nid); 
    if ($display_ad_category) {
      $term = _ed_classified_get_primary_category($x);
      if ($term) {
        $content .= ' <span class=\'classified-block-ad-term\'>'. l("($term->name)", _ed_classified_make_category_path($term->tid))  . '</span>'; // TODO: themeable function
      }
    }
    if ($display_timestamp) {
      $content .= ' <span class=\'classified-block-ad-age\'>(' . format_interval(time() - $x->timestamp,2) . t(' ago') .') </span>';
    }
    if ($display_counter) {
      $content .= ' <span class=\'classified-block-ad-count\'>(' . $x->counter. ') </span>';
    }
    if (node_last_viewed($x->nid) < $x->changed) 
      $content .= theme_mark();
    $content .= '</li>';
  }
  $content .= '</ul></div>';
  return $content;
}

/**
 * Implementation of hook_cron().
 */
function ed_classified_cron() {
  $time = time();
  // debug
  //$time += _ed_classified_days_to_seconds( _ed_classified_variable_get('default_ad_duration', EDI_CLASSIFIED_VAR_DEF_EXPIRATION_DAYS)) + _ed_classified_days_to_seconds(1) ;
  // end debug
  if (_ed_classified_variable_get('send_email_reminders', EDI_CLASSIFIED_VAR_DEF_SEND_EMAIL_REMINDERS)) {
    _ed_classified_process_notification_emails($time);
  }

  _ed_classified_expire_ads($time);

  /* 
   * Purge ads that have expired anytime between the start of time, and nn days ago
   */
  $purge_starttime=0; // is there a better way to do this?
  $purge_endtime=$time -  _ed_classified_days_to_seconds(_ed_classified_variable_get('ad_expired_purge_age', EDI_CLASSIFIED_VAR_DEF_PURGE_AGE));
  _ed_classified_purge_ads($purge_starttime, $purge_endtime);
}

/** 
 * convert days to # seconds
 */ 

function _ed_classified_days_to_seconds($days) {
  return $days * 86400; // 60 * 60 * 24 = 86400
}

/**
 * Process notification email handling on cron run.
 * @param $time The timestamp to use for email processing.
 * This allows us to use a consistent timestamp value, 
 * and push in fake values for testing and diagnostic
 * purposes.
 */

function _ed_classified_process_notification_emails($time)
{
  // get a cutoff date for expiring classified ads
  $email_notify_end_date = $time + _ed_classified_days_to_seconds(_ed_classified_variable_get('ad_expiration_email_warning_days', 3));
  //  _ed_classified_notify_ads_expiring_between($time,$email_notify_end_date); // TODO: probably don't need this.
  _ed_classified_notify_advertisers_periodic($time);
}

/**
 * Process "periodic" notifications
 * Create a notification if a user has ads nearing expiration
 */
function _ed_classified_notify_advertisers_periodic($time) {
  $parms = _ed_classified_displayname_parms();
  // TODO: only run this once a day (or period defined by variable 'email_reminder_period_secs'
  if (_ed_classified_periodic_notification_time($time)) {
    if (module_exist('ed_notify_api')) {
      // get list of users having published ads, and the nids of the ads
      $result = db_query('SELECT DISTINCT({node}.uid) FROM {edi_classified_nodes} INNER JOIN {node} ON {edi_classified_nodes}.nid = {node}.nid WHERE {node}.status = 1);'); 
      if ($result) {
        $count = 0;
        while ($uid = db_result($result,$count++)) {
          echo "uid=$uid ";
          // TODO: record notification
          // Use user's uid and "classified-ad-periodic" as the key value so we can 
          // ensure that there will only be one notification in the user's queue.
          $key = md5("classified-ad-per-remind:$uid");
          $success = ed_notify_api_record($time, $uid, 0, t('@name reminder', $parms, NULL, $key, ED_NOTIFY_API_TYPE_DEFAULT, TRUE));
        } // while (...)
      } // if $result
      //
      // now record the fact that we processed notifications
      _ed_classified_record_periodic_notifications(time());
    } // module_exist(...);
    else {
      _edi_wd('ed_notify_api.module not present or enabled.  Cannot send notifications', WATCHDOG_WARNING);
    }
  } // time to notify
}

/**
 * Record last periodic notification processing time
 */
function _ed_classified_record_periodic_notifications($time) {
  _ed_classified_variable_set('email_reminders_last_sent', $time);
}
/**
 * Return TRUE if we need to send periodic notifications according to time and configuration options
 */
function _ed_classified_periodic_notification_time($time) {
  $last_notify_time = _ed_classified_variable_get('email_reminders_last_sent', 0);
  $next_notify_time = $last_notify_time + _ed_classified_variable_get('email_reminder_period_secs'); // only update notifications if haven't been notified in over 24 hours

  return ($time > $next_notify_time);
}

/**
 * Notify owners of ads nearing expiration
 */ 
function _ed_classified_notify_ads_expiring_between($start_date, $end_date) {
  // Get list of ads expiring between $start_date, and $end_date
  // Group the list by n.uid so we can process them using a single email.
  //   - get list of users having ads that expire soon
  //   - for each user
  //     get list of ads expiring soon (n.nid == classified.nid)

  // TODO: do we need the lower limit ($start_date) here?  Probably not
  $query="SELECT n.nid, n.title, n.created, n.uid, cn.expires_on FROM {node} n, {edi_classified_nodes} cn where n.type='ed_classified' AND n.status = 1 AND cn.expires_on > %d AND cn.expires_on < %d ;";
  $qr = db_query($query, $start_date, $end_date);
  while ($node = db_fetch_object($qr)) {
    // TODO: include a bailout to prevent hogging CPU (no more than NN seconds?)
    // get user email address for $nid
    $user = user_load(array('uid'=>$node->uid));
    if ($user) {
      $expires = _ed_classified_get_ending_date_html($node->expires_on);
      // echo "$node->title $expires,  USER: $user->uid $user->name $user->mail<br/>";
      // send an email via user_mail(...) api http://api.drupal.org/api/4.7/function/user_mail
      // record date sent
      // "UPDATE {edi_classified_nodes} SET expiration_notify_last_sent = %d
      if (module_exist('ed_notify_api')) {
        // TODO: record notification
      }
    }
  }
}

/**
 * expire old ads 
 */

function _ed_classified_expire_ads($time) {
  // mark ads matching criteria.  Set  $node->status=>unpublished, 
  $query = _ed_classified_get_aged_ads(0, $time, 1); // get published but old ads 
  while ($node = db_fetch_object($query)) {
    _ed_classified_unpublish_ad($node->nid);
    // TODO: notify user of ad expiration
    _ed_classified_notify_user_of_ad_expiration($node);
  }
}

/**
 * Unpublish a node
 * Lifted from spam module (jeremy [at] kerneltrap.org)
 */

function _ed_classified_unpublish_ad($nid)
{
  $result = db_query('UPDATE {node} SET status = 0 WHERE nid = %d', $nid);
  _edi_wd(t('Unpublished ad nid=%nid', array('%nid'=>$nid)), WATCHDOG_NOTICE, l(t('View ad'), "node/$nid"));
     
}

/**
 * purge old ads (must have been expired - IOW, unpublished - first.)
 */

function _ed_classified_purge_ads($time_start, $time_end) {
  $query = _ed_classified_get_aged_ads($time_start,$time_end, 0); // get unpublished ads whose time has come
  $count = 0;
  while ($node = db_fetch_object($query)) {
    _ed_classified_purge_ad($node);
    $count++;
  }
  if ($count>0) {
    _edi_wd(sprintf(t('Purged %d ads expired between %s and %s'), $count, _edi_safe_date_fmt($time_start), _edi_safe_date_fmt($time_end)));
  }
}

/**
 * "purge" an expired ad 
 * (This will delete a classified ad that has been 'expired' and is older than the threshold)
 */
function _ed_classified_purge_ad($node) {
  $expired = _ed_classified_get_ending_date_string($node->expires_on);
  _edi_wd(t('Purging ad :title (nid=:nid) which :expired', array(':title'=>$node->title, ':nid'=>$node->nid, ':expired'=>$expired)));
  _ed_classified_delete_ad($node->nid);
}

/**
 * Delete the ad
 * lifted from spam module
 */
function _ed_classified_delete_ad($nid) {
  if ($nid == 0)
    return;
  $node = node_load(array('nid' => $nid));
  if ($node && $node->nid != 0) {
    if ( 0 == $node->status && _ed_classified_node_is_classified($node) ) {  // sanity check: must be unpublished, since it should have been expired, and it should be proper node type
      node_delete($nid);
      _edi_wd(t('Deleted :type nid=!nid <em>":subject"</em>.', array(':type' => node_get_types('name', $node), ':subject' => $node->title, '!nid'=>$node->nid)));
    } else {
      // sanity
      _edi_wd(t('Node !nid not purged because it wasn\'t a classified ad, or hadn\'t expired: :type <em>":subject"</em>.', array('!nid'=>$node->nid, ':type' => node_get_types('name', $node), ':subject' => $node->title)));
    }
  }
}

/**
 * Notify user of ad expiration
 * (Actually, this just queues a notification
 */
function _ed_classified_notify_user_of_ad_expiration($node) {
  _ed_classified_queue_notification($node, EDI_CLASSIFIED_NOTIFICATION_AD_EXPIRED);
}

/**
 * Queue up a user notification
 */

function _ed_classified_queue_notification($node, $type) {
  // TODO: integrate with notification api
}

/**
 * Is a node really a classified ad?
 */

function _ed_classified_node_is_classified($node) {
  return EDI_CLASSIFIED_MODULE_NAME == $node->type;
}

/** 
 * Get a query result with any ads that have expired prior to a given date, and having a specific publish status
 */
function _ed_classified_get_aged_ads($expire_time_start, $expire_time_end, $status=1) {
  return db_query("SELECT * FROM {node} n, {edi_classified_nodes} ec WHERE n.type='ed_classified' AND n.vid = ec.vid  AND n.status = %d AND (ec.expires_on >= %d AND ec.expires_on <= %d)", $status, $expire_time_start, $expire_time_end );
}

/**
 * Implementation of hook_form_alter().
 * For image ads, we suggest using attachments and the upload_image module.  If the upload_image module is enabled,
 * and the classified ad node type has an 'attachments' form element, this function will
 * add explanatory text to help users understand how to add an image to their ads.
 * Also, this will un-collapse the attachments block, so that it is visible at all times.
 * If you don't want this feature, disable it in admin/settings
 */

function ed_classified_form_alter($form_id, &$form) {
  if ($form['type']['#value'] == EDI_CLASSIFIED_MODULE_NAME) {
    if ($form_id == 'ed_classified_node_form' && $form['attachments'] && _ed_classified_variable_get('alter_attachment_text', EDI_CLASSIFIED_VAR_DEF_ALTER_ATTACHMENT_TEXT) ) {
      // Don't allow the attachments block to be collapsed.
      $form['attachments']['#collapsed']=FALSE;
      $form['attachments']['#collapsible']=FALSE;
      // Enhance the help for classified ads.
      // NOTE: this is approprate for the upload_image module enhancements only!
      $form['attachments']['#title']=t('Photo Attachments');
      $form['attachments']['#description']= _ed_classified_variable_get('alter_attachment_text_description', t(EDI_CLASSIFIED_VAR_DEF_ALTER_ATTACHMENT_TEXT_DESCRIPTION));
    }
  }
} 


/**
 * Implementation of hook_help().
 */
function ed_classified_help($section) {
  $parms = _ed_classified_displayname_parms();
  switch ($section) {
  case 'admin/help#ed_classified':
    return t('You can manage current @name using this page.', $parms);
  case 'admin/modules#description':
    return t('@name module', $parms);
  case 'node/add#ed_classified':
    return t('Create a @name.', $parms);
    // OPTIONAL: Add additional cases for other paths that should display help text.
  }
}


/**
 * Implementation of hook_link().
 */
function ed_classified_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();
  global $user;

  if (_ed_classified_node_is_classified($node)) {  
      if (user_access('access user profiles') && _ed_classified_variable_get('show_contact_form_link_on_posts', TRUE) && _ed_classified_module_exists('contact')) {
      $ad_author = user_load(array('uid'=>$node->uid));
        if ($ad_author  && $user->uid != $ad_author->uid && $ad_author->uid != 0) {
        $links['ed_classified_contact'] = 
          array('title'=>t('View the advertiser\'s (:advertiser) profile.', array(':advertiser'=> $ad_author->name)),
                'href' => 'user/' . $ad_author->uid,
                'html' => TRUE);
      }
    }
    
    // Show contact link
    
    if (0 != $user->uid && module_exists('contact')) { // only if logged in and there's a sitewide contact form
      $links['ed_classified_suggest_new_category'] = 
        array('title' => t('Suggest a new category'),
              'href' => 'contact', 
              'attributes' => array('title'=>t('Click here to suggest a new classified ad category')));
    }
  }
  return $links;
}

/**
 * Implementation of hook_link_alter (D5)
 * Find and destroy old taxonomy links for the classified ads node.  This  
 * will create links to the custom classified ads taxonomy view.
 * This would be easier if the hook callback knew what module was calling it,
 * and the type of links that were just added.  Since we don't we have to 
 * do some checking to find what we are looking for.
 */
function ed_classified_link_alter(&$node, &$links) {
  // array with keys like [taxonomy_term_n] => title, href, etc.
  if (_ed_classified_node_is_classified($node)) {
    $tax = $node->taxonomy;
    foreach ($tax as $t) {
      // kill any links like taxonomy_term_n
      // OR, replace them with links to ed_classified/tid/n?
      $key = 'taxonomy_term_'.$t->tid;
      if (_ed_tid_is_classified_term($t->tid) && isset($links[$key])) {
        $links[$key]['href'] = _ed_classified_make_category_path($t->tid);
        $links[$key]['attributes'] = array('title' => t('View other ads like this one in the \'!cat\' category.', array('!cat' => $t->name)));
      }
    }
  }
}


/**
 * Is a tid a 'classified' term?  Is a tid a child of our taxonomy?
 * @param $tid The term id to check.
 * @return true if the term is a child of our vocabulary.
 */

function _ed_tid_is_classified_term($tid) { 
  $vid = _ed_classified_get_vid();
  $vocab = taxonomy_get_vocabulary($vid);
  $term = taxonomy_get_term($tid);
  if ($vocab->hierarchy && $vocab->module == EDI_CLASSIFIED_MODULE_NAME) {
    return $term->vid == $vid;
  }
  else {
    _edi_wd(t('Internal error: Vocabulary !vid (:vocab_name) is not our dedicated classified ads vocabulary - someone has tampered with the vocabulary, or our stored variables.', array('!vid' => $vid, ':vocab_name' => $vocab->name)), WATCHDOG_ERROR);
    return FALSE; // sanity check: not possible since the vocab is not hierarchical or is not our vocabulary
  }
}
/**
 * Implementation of hook_menu().
 */
function ed_classified_menu($may_cache) {
  global $user;
  $items = array();
  $parms = _ed_classified_displayname_parms();
  $name = _ed_classified_displayname();
  if (!$may_cache) {
    // inject our css per http://api.drupal.org/api/HEAD/function/hook_init and http://api.drupal.org/api/HEAD/function/hook_menu
    drupal_add_css(drupal_get_path('module',  EDI_CLASSIFIED_MODULE_NAME) .'/ed_classified.css');
  }

  if ($may_cache) {
    $items[] = array('path' => EDI_CLASSIFIED_MODULE_NAME, 
                     'title' => $name,
                     'access' => user_access('access content'),
                     'type' => MENU_NORMAL_ITEM, // MENU_SUGGESTED_ITEM,
                     'callback' => 'ed_classified_page');
    $items[] = array(
                     'path' => 'node/add/' . EDI_CLASSIFIED_MODULE_NAME,
                     'title' => $name, 
                     'access' => user_access('create classified ads'),
                     );
    $items[] = array( 
                     'path' => 'admin/content/node/' . EDI_CLASSIFIED_MODULE_NAME,
                     'title' => $name, 
                     'access' => user_access('administer classified ads'),
                     'type'     => MENU_NORMAL_ITEM,
                     'callback' => 'ed_classified_admin_overview'
                     );
    $items[] = array(
                     'path' => 'admin/settings/'. EDI_CLASSIFIED_MODULE_NAME,
                     'title' => $name, 
                     'description' => t('Configure @name settings', $parms), 
                     'callback' => 'drupal_get_form',
                     'callback arguments' => array('ed_classified_admin_settings'),
                     'access' => user_access('administer site configuration'),
                     'type' => MENU_NORMAL_ITEM, // optional
   );
  } else {
    if (arg(0) == 'user' && is_numeric(arg(1))) {
      $account = user_load(array('uid' => arg(1)));
      if ($user !== FALSE && $account->uid) {
        $items[] = array(
                         'path' => 'user/'.$account->uid.'/'.EDI_CLASSIFIED_MODULE_NAME,
                         'title' => t('My @name list', $parms),
                         'callback' => 'ed_classified_by_user',
                         'callback arguments' => array(arg(1)),
                         'access' => user_access('access user profiles'),
                         'type' => MENU_LOCAL_TASK,
                         );
      }
    }
  }

  return $items;
}

/**
 * Present admin options.
 */

function ed_classified_admin_overview($uid=0) {
  global $user;
  $can_edit = (1 == $user->uid) || ($uid == $user->uid && user_access('edit own classified ads'));

  $header = array(
                  array('data' => t('Title'),        'field' => 'title'),
                  /*    array('data' => t('Creator'),      'field' => ' */
                  array('data' => t('Created'),    'field' => 'created'),
                  array('data' => t('Published?'), 'field' => 'status'),
                  array('data' => t('Expires'),      'field' => 'expires_on'),
                  $can_edit ? array('data' => t('Edit')) : '',
                  );
  $user_select ='';
  if ($uid != 0) {
    $user_select = "AND n.uid = $uid";
  }
  $sql = "SELECT * FROM {node} n, {edi_classified_nodes} ec WHERE n.vid = ec.vid $user_select "  . tablesort_sql($header);
  $result = pager_query($sql, 50);
  $time = time();
  while ($ad = db_fetch_object($result)) {
    $expired = ed_classified_ad_expired($ad,$time);
    // TODO: need to show reported miscategorized ads.
    $rows[] = array(
                    array('data' => l($ad->title, "node/$ad->nid")), 
                    array('data' => format_date($ad->created, 'custom', 'n/j/y'), 'nowrap'=> 'nowrap'),
                    array('data' => $ad->status ? t('yes') : t('no')),
                    array('data' => $expired ? t('expired') : format_date($ad->expires, 'custom', 'n/j/y', $ad->expires_on) . t(' (').format_interval($ad->expires_on-$time, 2) .t(')'), 'nowrap' => 'nowrap', 
                          'class'=>$expired ? 'classified-expired-flag' : 'classified-unexpired-flag'),
                    $can_edit ? array('data' => ' [' . _ed_classified_make_edit_link($ad, 'edit') .']') : '', 
                    );
  }
  return theme('table', $header, $rows) . theme('pager', NULL, 50, 0);
}

/**
 * Get a list of classified ads for a given user
 */
function ed_classified_by_user($uid=0) {
  return ed_classified_admin_overview($uid);
}

/**
 * Display a page of classified ads, as appropriate.
 * Lifted from image_gallery module.  Shameless.
 */

function ed_classified_page($type = NULL, $tid = 0) {
  // get a list of categories and counts
  $cats = taxonomy_get_tree(_ed_classified_get_vid(), $tid, -1, 1);
  for ($i=0; $i < count($cats); $i++) {
    $cats[$i]->count = taxonomy_term_count_nodes($cats[$i]->tid, EDI_CLASSIFIED_MODULE_NAME);
    $tree = taxonomy_get_tree(_ed_classified_get_vid(), $cats[$i]->tid, -1);
    $descendant_tids = array_merge(array($cats[$i]->tid), array_map('_taxonomy_get_tid_from_term', $tree));
    $last = db_fetch_object(db_query_range(db_rewrite_sql('SELECT n.nid FROM {node} n INNER JOIN {term_node} tn ON n.nid = tn.nid WHERE tn.tid IN (%s) AND n.status = 1 ORDER BY n.sticky DESC, n.created DESC'), implode(',', $descendant_tids), 0, 1));
    $cats[$i]->latest = node_load(array('nid' => $last->nid));
  }

  // TODO: order by created date, #views, what?
  $ads = array();
  //  echo "tid=$tid<br>";  var_dump($tid);
  if ($tid) {
    $result = pager_query(db_rewrite_sql("SELECT n.nid FROM {term_node} t INNER JOIN {node} n ON t.nid=n.nid WHERE n.status=1 AND n.type='ed_classified' AND t.tid=%d ORDER BY n.sticky DESC, n.created DESC"), _ed_classified_variable_get('ads_per_page', 10), 0, NULL, $tid);
    while ($node = db_fetch_object($result)) {
      $ads[] = node_load(array('nid' => $node->nid));
    }
    //    var_dump($ads);
    $classified_cat = taxonomy_get_term($tid);
    $parents = taxonomy_get_parents($tid);
    foreach ($parents as $parent) {
      $breadcrumb[] = array('path' => _ed_classified_make_category_path($parent->tid), 'title' => $parent->name);
    }
    $breadcrumb[] = array('path' => EDI_CLASSIFIED_MODULE_NAME, 'title' => _ed_classified_displayname());
    $breadcrumb = array_reverse($breadcrumb);
    drupal_set_title($classified_cat->name);
  }

  $breadcrumb[] = array('path' => $_GET['q']);
  menu_set_location($breadcrumb);

  $content = theme('ed_classifieds', $cats, $ads);
  return $content;
}

/**
 * Theme a classified ads taxonomy browser page
 */

function theme_ed_classifieds($cats, $ads) {
  $content = '';

  if (count($cats)) {
    $row_count = 0;
    $content.= '<ul class="classified-category-list">';
    foreach ($cats as $cat) {
      $row_style = ($row_count % 2 == 0) ? 'even' : 'odd';
      $content .= "<li class ='$row_style' >";
      // 'preview' (was thumbnail of latest image)
      //      if ($cat->count)
      //        $content.= l('foo', _ed_classified_make_category_path($cat->tid), array(), NULL, NULL, FALSE, TRUE);
      $content.= '<div class=\'classified-cat-name\'>' . t('Category: ') . l($cat->name, _ed_classified_make_category_path($cat->tid)) . "</div>\n";
      if (trim($cat->description) != '')
        $content.= '<div class="classified-description">'. check_markup($cat->description) ."</div>\n";
      // TODO: get preview list 
      if ($cat->latest) {
        $content .= '<div class=\'title\'>' . t('Latest ad: ') . l($cat->latest->title, 'node/'.$cat->latest->nid) . '</div>';
        $content .= '<div class=\'created\'>' . t('Created on ') . format_date($cat->latest->created) . ' (' . format_interval(time() - $cat->latest->created) . ' ago) </div>';
      }
      $content.= '<div class="status">' . format_plural($cat->count, 'There is one ad in this category.', 'There are @count ads in this category.');
      if ($cat->latest->changed) {
        $content.= t('  Last updated: !date', array('!date' => format_date($cat->latest->changed)));
      }
      $content .="</div>\n"; // class="status"
      $content.= "</li>\n";
      $row_count ++;
    }
    $content.= "</ul>\n";
  }

  if (count($ads)) {
    $content.= '<ul class="classified_ad_list">';
    foreach ($ads as $ad) {
      $content .= '<li';
      if ($ad->sticky) {
        $content .= ' class="sticky"';
      }
      $content .= ">\n";
      $content .= '<h3>'.l($ad->title, 'node/'.$ad->nid)."</h3>";
      $content .= '<div class=\'classified-description\'>' . check_markup($ad->body, $ad->format) . '</div>';
      if (theme_get_setting('toggle_node_info_' . $ad->type)) {
        $content .= '<div class="classified_author">'. t('Posted by: @name', array('@name' => theme('username', $ad))) . "</div>\n";
        if ($ad->created > 0) {
          $content .= '<div class="classified_date">' . t('Created on ') .  format_date($ad->created)."</div>\n";
        }
        $expires = ed_classified_get_ad_expiration($ad->nid);
        if ($expires > 0) {
          $content .= '<div class="classified-date">' .  _ed_classified_get_ending_date_html($expires) . "</div>\n";
        }
      }
      $content .= "</li>\n";
    }
    $content.= "</ul>\n";
  }

  if ($pager = theme('pager', NULL, _ed_classified_variable_get('ads_per_page', 10), 0)) {
    $content.= $pager;
  }

  if (count($ads) + count($cats) == 0) {
    $content.= '<p class="classified_count">' . format_plural(0, 'There is @count ad in this category', 'There are @count ads in this category') . "</p>\n";
  }
  return $content;
}

/** 
 * Get the expiration date of a classified ad node
 */
function ed_classified_get_ad_expiration($nid) {
  $expires = 0;// TODO: need windows-compatible old date - use time()?
  $q = db_query("select expires_on from {edi_classified_nodes} ecn where ecn.nid = %d;", $nid);
  if ($q && db_num_rows($q) != 0)
    $expires = db_result($q);
  return $expires;
}

/**
 * Implementation of hook_perm().
 */
function ed_classified_perm() {
  return array('create classified ads', 'edit own classified ads', 'reset classified ad expiration', 'administer classified ads');
}


/**
 * Implementation of hook_settings().
 */
function ed_classified_admin_settings() {
  _ed_classified_check_settings();
  $vid = _ed_classified_get_vid(); // ensure that taxonomy is created
  $form[_ed_classified_cfg_varname('settings_updated')] = array('#type' => 'hidden', '#value' => time());// lifted from image.module - neat trick

  $form['module_banner'] = array('#type' => 'markup', 
                                 '#value' => '<div style="border: solid 1px #eee; margin: .5em; padding: .5em;" <strong>Module development sponsored by <a href="http://exodusdev.com">Exodus Development</a></strong><br/>');
  $form['module_id'] = array('#type' => 'markup', '#value' =>  EDI_CLASSIFIED_MODULE_VERSION .'<br/></div>');


$form['expiration'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#title' => t('Ad Duration and Expiration'),
  );
  $form['expiration'][ _ed_classified_cfg_varname('default_ad_duration')] = array('#type' => 'textfield', '#title'=>t('New ad default duration (days)'), '#default_value' => _ed_classified_variable_get('default_ad_duration', EDI_CLASSIFIED_VAR_DEF_EXPIRATION_DAYS), '#size'=>'3', '#maxlength'=>3, '#description'=>t('Ads will auto-expire this many days after the ad is created, unless you override this on a per-category basis (see below.).  Requires cron.'), '#required'=>TRUE);

  $form['expiration'][ _ed_classified_cfg_varname('ad_expired_purge_age')] = array('#type' => 'textfield', '#title'=>t('Grace period: purge expired ads after this many days.'), '#default_value' => _ed_classified_variable_get('ad_expired_purge_age', EDI_CLASSIFIED_VAR_DEF_PURGE_AGE), '#size'=>'3', '#maxlength'=>3, '#description'=>t('Expired ads will be purged this many days after expiration.  Requires cron.'), '#required'=>TRUE);

$form['content_policy'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#title' => t('Ad Content Policy'),
  );
  $form['content_policy'][ _ed_classified_cfg_varname('ad_standard_body_length')] = array('#type' => 'textfield', '#title'=>t('Body length limit for standard ads'), '#default_value' => _ed_classified_variable_get('ad_standard_body_length', EDI_CLASSIFIED_VAR_DEF_BODYLEN_LIMIT), '#size'=>'6', '#maxlength'=>5, '#description'=>t('Maximum characters to allow in classified ad body.'), '#required'=>TRUE);

  $form['content_policy'][ _ed_classified_cfg_varname('show_contact_form_link_on_posts')] = array('#type' => 'checkbox', '#title'=>t('Show contact link on classified ad posts'), '#default_value' => _ed_classified_variable_get('show_contact_form_link_on_posts', EDI_CLASSIFIED_VAR_DEF_SHOW_CONTACT_LINK_ON_POSTS), '#description' => t('Provide contact link in classified ad links.  Not necessary if you provide an alternative method of contacting advertisers, such as the privatemsg module).'), '#required'=>FALSE);

  /* UNIMPLEMENTED
  $form[ _ed_classified_cfg_varname('send_email_reminders')] = array('#type' => 'checkbox', '#title'=>t('Send email reminders'), '#default_value' => _ed_classified_variable_get('send_email_reminders', EDI_CLASSIFIED_VAR_DEF_SEND_EMAIL_REMINDERS), '#description' => t('Send reminder emails to advertisers periodically'), '#required'=>FALSE);
  $form[ _ed_classified_cfg_varname('ad_expiration_email_warning_days')] = array('#type' => 'textfield', '#title'=>t('Days before expiration to send reminder emails'), '#default_value' => _ed_classified_variable_get('ad_expiration_email_warning_days', 3), '#size'=>'3', '#maxlength'=>3, '#required'=>TRUE);
  */

$form['file_attachment_enhancements'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('File Attachment Enhancements'),
  );

  $form['file_attachment_enhancements'][ _ed_classified_cfg_varname('alter_attachment_text')] = array('#type' => 'checkbox', '#title'=>t('Alter classified ad create/edit form file attachment text'), '#default_value' => _ed_classified_variable_get('alter_attachment_text', EDI_CLASSIFIED_VAR_DEF_ALTER_ATTACHMENT_TEXT), '#description' => t('If selected, this option will enhance classified node edit forms where attachments are enabled - altering form behavior to help users with attaching an image.'), '#required'=>FALSE);

  $form['file_attachment_enhancements'][ _ed_classified_cfg_varname('alter_attachment_text_description')] = array('#type' => 'textarea', '#title'=>t('File attachment description text'), '#default_value' => _ed_classified_variable_get('alter_attachment_text_description', EDI_CLASSIFIED_VAR_DEF_ALTER_ATTACHMENT_TEXT_DESCRIPTION), '#description' => t('If you choose to alter the file attachment form behavior, this text will be shown.'), '#required'=>TRUE);

  $form['taxonomy_settings'] = 
    array('#type' => 'fieldset',
          '#collapsible' => TRUE,
          '#collapsed' => FALSE,
          '#title' => t('Taxonomy-dependent settings'),
            '#description' => t('Ad duration, in days, for the ads created in each category.  Ads expire this many days after creation in this category - note that changing the category after creation will not change the expiration date unless the author resets the expiration.  Ads assigned more than one category at the time of creation or editing receive the maximum duration found in all assigned categories. '),
          );

  // get terms
  $taxonomy = taxonomy_get_tree(_ed_classified_get_vid());
  //  _dbg($taxonomy);
  foreach ($taxonomy as $t) {
    $name = _ed_classified_cfg_varname('tid_' . $t->tid . '_duration');
    $parms =  array(':name' => $t->name, ':tid' => $t->tid);
    $form['taxonomy_settings'][$name] = 
      array('#type' => 'textfield',
            '#size' => 10,
            '#maxlength' => 4, 
            '#title' => t('Ad duration for Category \':name\'', $parms),
            '#default_value' => _ed_classified_get_duration($t->tid),
            '#prefix' => '<div style="margin: ' . $t->depth * 2 . 'em; margin-top: 0; margin-bottom: 0;">',
            '#suffix' => '</div>',
            );
  }

  return system_settings_form($form);
}

/**
 * do the sanity-check dance.
 */
function _ed_classified_check_settings() {
  /*******
   // expiration warning days must be < new ad default duration
   $duration = _ed_classified_variable_get('default_ad_duration', EDI_CLASSIFIED_VAR_DEF_EXPIRATION_DAYS);
   $warn = _ed_classified_variable_get('ad_expiration_email_warning_days', 3);

   if ($duration <= $warn || $warn <1) {
   form_set_error(_ed_classified_cfg_varname('ad_expiration_email_warning_days'), t('Email reminder value must be greater than zero and less than the ad duration (%duration days)', array('%duration'=>$duration)));
   } 
   if ($duration <1) {
   form_set_error(_ed_classified_cfg_varname('default_ad_duration'), t('Ad duration must be greater than zero'));
   }
  *****/
}

/**
 * Implementation of hook_access().
 */
function ed_classified_access($op, $node) {
  global $user;
  //echo "hook_access: $op, $node->nid, $user->uid, $node->uid<br/>";
  if ($op == 'create') {
    return user_access('create classified ads');
  }

  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own classified ads') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_delete().
 */
function ed_classified_delete(&$node) {
  db_query('DELETE FROM {edi_classified_nodes} WHERE nid = %d', $node->nid);
}


/**
 * Implementation of hook_form().
 */
function ed_classified_form(&$node,&$param) {
  $type = node_get_types('type', $node); 
  $form['title'] = array(
                         '#type' => 'textfield',
                         '#title' => check_plain($type->title_label),
                         '#required' => TRUE,
                         '#default_value' => $node->title,
                         '#weight' => -5
                         );
  $max_body_length = _ed_classified_variable_get('ad_standard_body_length', EDI_CLASSIFIED_VAR_DEF_BODYLEN_LIMIT);
  $current_body_length = strlen($node->body);
  $form['body_filter']['body'] = array(
                                       '#type' => 'textarea',
                                       '#title' => check_plain($type->body_label), 
                                       '#default_value' => $node->body,
                                       '#required' => TRUE,
                                       '#description' => t('The main body text of your ad.  Please note that ads are limited to !limit characters or less.', array('!limit'=>$max_body_length)),
                                       '#rows' => 10,
                                       // Add a length counter so people know they have gone over.
                                       // http://lists.evolt.org/archive/Week-of-Mon-20040315/156773.html
                                       // TODO: This should be a part of the jstools module... 
                                       // TODO: need a function and handle onblur, focus, etc. so clipboard paste works.
                                       // Use behaviors js rather than this clunky code?
                                       // onkeypress doesn't detect all keys in IE.  Use onkeydown/onkeyup
                                       '#attributes'=>array('onkeyup'=>"document.getElementById('_edi_classified_body_length_remaining').innerHTML=this.value.length;document.getElementById('_edi_classified_body_length_remaining').style.color=(this.value.length<=$max_body_length?'black':'red');"),    
                                       );
  $form['body_filter']['body_length_remaining'] = array('#value'=>t('<strong>Characters used: <span id="_edi_classified_body_length_remaining">:initial_value</span> of :max_value</strong>', array(':initial_value'=>$current_body_length, ':max_value'=>$max_body_length)), 
                                                        '#weight'=>-1);
  // END counter code
  $form['body_filter']['filter'] = filter_form($node->format);

  /* Set up expiration info fieldset */
  if ($node->expires_on >0) {
    $form['expiration_fieldset'] = array('#type'=>'fieldset', '#title'=>t('Ad Expiration'), '#collapsible'=> TRUE, '#collapsed'=>FALSE, '#weight'=>-1);
    $form['expiration_fieldset']['expires_on_text'] = array('#value' => _ed_classified_get_ending_date_html($node->expires_on), '#weight'=>-15);
    // TODO: fix this - using hidden field to preserve value
    $form['expiration_fieldset']['expires_on'] = array('#type'=>'hidden', '#value'=>$node->expires_on); 
    // TODO: if has proper perms, allow editing of expiration date as appropriate
    if (user_access('reset classified ad expiration') && user_access('edit own classified ads') && $node->expires_on >0) {
      $form['expiration_fieldset']['reset_expiration'] = 
        array('#type'=>'checkbox', '#default_value'=>'0', 
              '#title'=>t('Reset ad expiration (extend expiration date)'), 
              '#description'=> t('If this is checked, the ad\'s expiration date will be reset upon saving changes.  Duration may depend on assigned categories.'));
    }
  }
  // TODO: Enter additional form elements
  // TODO: Expiration, contact info, category (from the classified taxonomy dedicated to classified)
  // if user has appropriate access, display and allow change of state, expiration date.
  if (user_access('administer classified ads')) {
    // show state here.
  }
  return $form;
}


/**
 * Implementation of hook_insert().
 */
function ed_classified_insert($node) {
  // TODO: Enter database insertion query here, for example:
  // db_query("INSERT INTO {node_example} (vid, nid, color, quantity) VALUES (%d, %d, '%s', %d)", $node->vid, $node->nid, $node->color, $node->quantity);
  db_query("INSERT INTO {edi_classified_nodes} (vid, nid, expires_on) VALUES (%d, %d, %d)", $node->vid, $node->nid, $node->expires_on);
}


/**
 * Implementation of hook_load().
 */
function ed_classified_load($node) {
  // TODO: Obtain and return additional fields added to the node type, for example:
  // $additions = db_fetch_object(db_query('SELECT color, quantity FROM {node_example} WHERE vid = %d', $node->vid));
  $additions = db_fetch_object(db_query('SELECT * FROM {edi_classified_nodes} WHERE vid = %d', $node->vid));
  return $additions;
}


/**
 * Implementation of hook_node_info().
 */
function ed_classified_node_info() {
  // beware: these must match nodeapi value; name must be same as $node->type for spam module to add spam reporting links
  return array(EDI_CLASSIFIED_MODULE_NAME => 
               array('name' => t('Classified Ads'), // cannot call node_get_types() since it ends up calling this code.
                     'module' => EDI_CLASSIFIED_MODULE_NAME,
                     'description' => t('Contains a title, a body, and an administrator-defined expiration date')));
}


/**
 * Implementation of hook_submit().
 */
function ed_classified_submit(&$node) {
  $terms = $node->taxonomy[_ed_classified_get_vid()];
  $expiration_changed = FALSE;
  $expiration_old = $node->expires_on;
  $expiration =  time() +  _ed_classified_days_to_seconds(_ed_classified_get_longest_duration($terms));
  $user_reset = $node->reset_expiration;
  if ($user_reset && !user_access('reset classified ad expiration')) {
    $user_reset = FALSE; // enforce permissions, just in case someone plays games with the form in an attempt to override perms
    global $user;
    _edi_wd(t('User %uid attempted to reset ad expiration date on node %nid without proper access permissions - hack attempt?', array('%uid' => $user->uid, '%nid' => $node->nid)));
  }

  // calc expiration date as appropriate
  // If new ad, or user wants to reset expiration, or taxonomy was changed... recalc expiration?
  if ($node->expires_on == 0 || $user_reset) {
    // it's a new ad, or the user chose to reset the expiration
    $node->expires_on = $expiration; // _ed_classified_get_default_ad_duration_in_seconds();
    // _edi_wd(sprintf('Ad expiration was %d (%s), now %d (%s)', $old_expires, _edi_safe_date_fmt($old_expires), $node->expires_on, _edi_safe_date_fmt($node->expires_on)));
    // if unpublished, re-publish the node.
    $node->status = 1;
    $expiration_changed = TRUE;
  }
  else {
    // This is not a new ad, and the user didn't choose to (or is not allowed to) reset the ad expiration
    // so, let's check the tentative new expiration, and if it's shorter than the current expiration - we need to use the new (shorter) one
    // Rationale: User may have changed the taxonomy terms for this ad (would be nice to be able to detect this accurately) and
    // we don't want someone to end up creating a long-living ad that they wouldn't be able to create by normal means
    if ($expiration < $node->expires_on) {
      $node->expires_on = $expiration;
      $node->status = 1; // re-publish
      $expiration_changed = TRUE;
    }
  }
  // log and notify if needed
  if ($expiration_changed) {
    $msg = t('Ad expiration changed from %expires_old to %expires_new due to edit', 
             array('%nid' => $node->nid, '%expires_old' => _edi_safe_date_fmt($expiration_old), '%expires_new' => _edi_safe_date_fmt($expiration)));
    _edi_wd($msg, WATCHDOG_NOTICE, l('view', 'node/'. $node->nid));
    drupal_set_message($msg);
  }

}

function _ed_classified_get_default_ad_duration_in_seconds() {
  $duration =  _ed_classified_days_to_seconds(_ed_classified_variable_get('default_ad_duration', EDI_CLASSIFIED_VAR_DEF_EXPIRATION_DAYS));
  return $duration;
}

/**
 * Find the longest duration, in days, for a given term or set of terms
 * @param $terms a singular term id, or an array of term id
 * @return the duration, in days, of the largest duration found.
 */
function _ed_classified_get_longest_duration($terms) {
  if (is_array($terms)) {
    $duration = 0;
    foreach ($terms as $term) {
      if ($term) {
        $d = _ed_classified_get_duration($term);
        if ($d > $duration) $duration = $d;
      }
    }
    return $duration; 
  }
  else {
    return _ed_classified_get_duration($terms);
  }
}
/**
 * Implementation of hook_update().
 */
function ed_classified_update($node) {
  if ($node->revision) {
    ed_classified_insert($node);
  }
  else {
    db_query("UPDATE {edi_classified_nodes} SET expires_on='%d' WHERE vid = %d", $node->expires_on, $node->vid);
  }
}


/**
 * Implementation of hook_validate().
 */
function ed_classified_validate(&$node) {
  // TODO: Enter form validation code here
  // Min/max expiration dates
  // settings: min/max expiration dates
  // 
  // TODO: allow override on some ads, if paid for longer ads
  $maxlen = _ed_classified_variable_get('ad_standard_body_length', EDI_CLASSIFIED_VAR_DEF_BODYLEN_LIMIT);
  if (strlen(trim($node->body)) > $maxlen) {
    form_set_error('body', t('Body length is limited to !length characters.  Please limit your entry to !length characters or less.', array('!length'=> $maxlen)));
  }
  // Ensure that classified ads category chosen is appropriate.
  /*  $vid = _ed_classified_get_vid();
   //  var_dump($node->taxonomy[$vid]);
   //  var_dump(taxonomy_get_children($node_taxonomy[$vid]));
   if ($node->taxonomy[$vid] && count(taxonomy_get_children($node->taxonomy[$vid])) != 0) {
   form_set_error(NULL, t('Please select a lower-level Classified Ad category'));
   }
  */
}


/**
 * Implementation of hook_view().
 */
function ed_classified_view($node, $teaser = FALSE, $page = FALSE) {
    if ($page /* && $node->type == EDI_CLASSIFIED_MODULE_NAME*/) { // FIXME: this needs to use new node type system 
      // modify the breadcrumbs and navigation
      $vid = _ed_classified_get_vid();
      $terms = taxonomy_node_get_terms_by_vocabulary($node->nid, $vid);
      $term = array_pop($terms);
      if ($term) {
        $vocab = taxonomy_get_vocabulary(_ed_classified_get_vid());
        // Breadcrumb navigation
        $breadcrumb = array();
        $breadcrumb[] = array('path' => 'ed_classified', 'title' => $vocab->name);
        if ($parents = taxonomy_get_parents_all($term->tid)) {
          $parents = array_reverse($parents);
          foreach ($parents as $p) {
            $breadcrumb[] = array('path' => _ed_classified_make_category_path($p->tid), 'title' => $p->name);
          }
        }
        $breadcrumb[] = array('path' => 'node/'. $node->nid);
        menu_set_location($breadcrumb);
      }
    }

  // TODO: Insert additional code (call to theme functions, etc.) to execute when viewing a node, for example:
  $node = node_prepare($node, $teaser);
  $node->content['body']['#value'] = theme('classified_body', $node);
  $node->content['teaser']['#value'] = theme('classified_teaser', $node);
  return $node;
}

/**
 * Implementation of hook_node_type()
 */

function ed_classified_node_type($op, $info) {
  if (!empty($info->old_type) && $info->old_type != $info->type) {
    $update_count = node_type_update_nodes($info->old_type,
      $info->type);

    if ($update_count) {
      $substr_pre = 'Changed the content type of ';
      $substr_post = strtr(' from %old-type to %type.', array(
        '%old-type' => theme('placeholder', $info->old_type),
        '%type' => theme('placeholder', $info->type)));
      drupal_set_message(format_plural($update_count, $substr_pre
        .'@count post'. $substr_post, $substr_pre .'@count posts'.
        $substr_post));
    }
  }
}

function theme_classified_teaser($node) {
  return '<div class=\'classified-teaser\'>'. $node->teaser . '</div><br/>' . _ed_classified_get_ending_date_html($node->expires_on);
}

function theme_classified_body($node) {
  return '<div class=\'classified-body\'>' . check_markup($node->body, $node->format) . '</div><br/>' .  _ed_classified_get_ending_date_html($node->expires_on);
}

/**
 * Get a formatted div with a readable, friendly ad expiration date.
 */
function _ed_classified_get_ending_date_html($ad_expiration_date) {
  $class = 'classified-expiration-info'; // standard expiration formatting
  $str = _ed_classified_get_ending_date_string($ad_expiration_date);
  // set style for ending soon
  if (_ed_classified_ad_expires_soon($ad_expiration_date)) {
    $class = 'classified-expiration-expires_soon'; // TODO: crappy name, fix this
  }
  if (_ed_classified_ad_expired_already($ad_expiration_date)) {
    $class = 'classified-expiration-expired'; // TODO: crappy name, fix this
  }
  return "<span class='$class'>" . $str . '</span>';
}

/**
 * Get just the raw text describing expiration date
 */
function _ed_classified_get_ending_date_string($ad_expiration_date) {
  // TODO: get time string for how long ago expired
  $interval = $ad_expiration_date - time();
  $expired = FALSE;
  if ($interval < 0) { $interval = -$interval; $expired =TRUE; }
  $str = '';
  if ($ad_expiration_date != 0) {
    $str = sprintf(t('%s on %s (%s%s)'), 
                   $expired ? t('expired') : t('expires'), 
                   format_date($ad_expiration_date), format_interval($interval, 2),
                   $expired ? t(' ago') : '');
  }
  return $str;
}
/**
 * Helper function: does $expiration date expire "soon" (soon depends on who you ask)
 */
function _ed_classified_ad_expires_soon($expiration_date) {
  return($expiration_date - time() > 0 && ($expiration_date - time()) < _ed_classified_days_to_seconds(3));  // TODO: use config var
}

/**
 * return true if ad has expired
 */
function _ed_classified_ad_expired_already($expiration_date) {
  return $expiration_date <= time();
}
/**
 * Returns (and possibly creates) a new vocabulary for classified
 * Lifted from image.module.
 * TODO: Create some built-in terms for the created taxonomy: Miscellaneous, Cars, Pets, etc. (look at craigslist for inspiration)
 */
function _ed_classified_get_vid() {
  $vid = _ed_classified_variable_get('vocabulary', '');
  if (empty($vid)) {
    // Check to see if classified ads vocabulary exists
    $vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE module='%s'", EDI_CLASSIFIED_MODULE_NAME)); 
    if (!$vid) {
      _edi_wd("Classified Ads taxonomy not found - creating taxonomy.");
      $vocabulary 
        = array('name' =>  _ed_classified_displayname(),
                'description' => t('Taxonomy required by Classified Ads (ed_classified) module.'), 
                'multiple' => '0', 
                'required' => '1', 
                'hierarchy' => '1', 
                'relations' => '0', 
                'module' => EDI_CLASSIFIED_MODULE_NAME, 
                'nodes' => array(EDI_CLASSIFIED_MODULE_NAME => 1)); 
      taxonomy_save_vocabulary($vocabulary);
      $vid = $vocabulary['vid'];
      $msg = "Classified Ads taxonomy" . $vocabulary->name . " (id=$vid) created.";
      _edi_wd($msg);
      drupal_set_message($msg);
      // TODO: create standard terms and subterms specified in external file (or, at a minimum, create a few standard categories)
      // taxonomy_save_term(...);
    }
    _ed_classified_variable_set('vocabulary', $vid);
  }

  return $vid;
}

/**
 * Make a 'path' to a category view for a given tid.
 */

function _ed_classified_make_category_path($tid) {
  return EDI_CLASSIFIED_MODULE_NAME . '/tid/' . $tid;
}

/**
 * Determine, in a version-friendly way, if a module exists.
 * some folks have decided to change module_exist() to module_exists() for 4.8/5.0.  see: http://drupal.org/node/79601
 */
function _ed_classified_module_exists($module) {
  $module_exists = FALSE;
  if (function_exists('module_exist'))
    $module_exists = module_exist($module); // 4.7
  if (function_exists('module_exists'))
    $module_exists = module_exists($module); // 4.8/5.0?
  return $module_exists;
}

/**
 * shortcut - log something to the watchdog log
 */
function _edi_wd($message, $severity = WATCHDOG_NOTICE, $link = NULL) {
  watchdog(EDI_CLASSIFIED_MODULE_NAME, $message, $severity, $link);
}

function _edi_safe_date_fmt($date) {
  return ($date ==0) ? "_the beginning of time_" : format_date($date);
}
/**
 * Determine whether a node is expired given a target timestamp
 * An ad is considered to have 'expired' if the $time parameter
 * is larger than the node's expires_on field.
 */

function ed_classified_ad_expired($node, $time) {
  if ($node->type != EDI_CLASSIFIED_MODULE_NAME)
    return FALSE;
  return ($time >= $node->expires_on);
}

/**
 * Helper gets content display name
 */

function _ed_classified_displayname() {
  $name = node_get_types('name', 'ed_classified');
  if (isset($name)) {
    return $name;
  }
  else {
    return 'undefined';
  }
}

function _ed_classified_displayname_parms() {
  $name = _ed_classified_displayname();
  $parms=array('@name' => $name, '!name' => $name, '%name' => $name );
  return $parms;
}

/** 
 * Make a node edit link
 */
function _ed_classified_make_edit_link($node, $text, $attributes=array()){
  return l($text, "node/$node->nid/edit", $attributes);
}

/**
 * Get duration in days for taxonomy term x; if nothing set, use the default value
 */
function _ed_classified_get_duration($tid) {
  $tid=(int)trim($tid);
  $def = _ed_classified_variable_get('default_ad_duration', EDI_CLASSIFIED_VAR_DEF_EXPIRATION_DAYS);
  $name = 'tid_' . $tid . '_duration';
  return _ed_classified_variable_get($name, $def);
}

/* ================= views.module integration ===================== */

/**
 * Experimental views integration - no guarantees express or implied.  
 * Use at your own risk.
 * See: http://drupal.org/node/42609
 */
function ed_classified_views_tables() {
  $parms = _ed_classified_displayname_parms();
  $parms['!modulename']=EDI_CLASSIFIED_MODULE_NAME;

  $tables['edi_classified_nodes'] 
    = array('name' => 'edi_classified_nodes',
            'join' => 
               array('left' => 
                     array('table' => 'node',
                           'field' => 'nid' ),
                            'right' => 
                     array('field' => 'nid')),
            'fields' => array('expires_on' 
                              => array('name' => t('!modulename: Ad Expiration', $parms),
                                       'handler' => array('views_handler_field_date' => 'As Date', 
                                                          'views_handler_field_date_custom' => 'As Custom Date'),
                                       'sortable' => true),
            'expires_on_delta' => array('name' => t('!modulename: Ad Expiration delta from current time'),
                                        'handler' => array('classified_views_handler_ad_expiration_delta' => 'As Interval', 
                                                           'views_handler_field_date_custom' => 'As Custom Date'),
                                        'sortable' => true,
                                        'notafield' => true,
                                        ),
                              ),
            );
  return $tables;
}

/**
 * Views handler for expiration 'delta' from current time
 */
function ed_classified_views_handler_ad_expiration_delta($fieldinfo, $fielddata, $value, $data) {
  $value = $data->edi_classified_nodes_expires_on;
  $time_now = time();
  $delta = $value ? $value - $time_now : 0;
  return format_interval($delta);
}




/* ================= views.module integration END  ===================== */

// generic debug function
/**
function _dbg($thing, $heading=NULL) {
  drupal_set_message("<strong>$heading</strong><pre>".htmlspecialchars(print_r($thing, true)).'</pre>');
}

*/